// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



use std::ops::{Add, Mul};
use std::mem;
use std::collections::HashMap;
use gmp::mpz::Mpz;

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
struct Ge([u64; 4]);

impl Ge {
    fn mulx(&mut self) {
        let reduce: [u64; 4] = if self.0[3] & (1 << 59) != 0 {
            [0xdaeac55dad3b8209, 0xcad38269931ba633, 0xd266e84818983b18, 0x1b2dd3aae5d32d17]
        } else {
            [0; 4]
        };

        let mut carry = 0;
        for n in 0..4 {
            let next = if self.0[n] & (1 << 63) != 0 { 1 } else { 0 };
            self.0[n] = reduce[n] ^ (self.0[n] << 1) ^ carry;
            carry = next;
        }
    }
}

impl<'a> Add<&'a Ge> for Ge {
    type Output = Ge;
    fn add(mut self, other: &Ge) -> Ge {
        for n in 0..4 {
            self.0[n] ^= other.0[n];
        }
        self
    }
}

impl<'a> Mul<&'a Ge> for Ge {
    type Output = Ge;
    fn mul(mut self, b: &Ge) -> Ge {
        let mut r = Ge([0; 4]);
        for n in 0..4 {
            for k in 0..64 {
                if b.0[n] & (1 << k) != 0 {
                    r = r + &self;
                }
                self.mulx();
            }
        }
        r
    }
}

impl Ge {
    pub fn exp(mut self, e: &[u8; 32]) -> Ge {
        let mut r = Ge([1, 0, 0, 0]);
        for n in 0..32 {
            for k in 0..8 {
                if e[n] & (1 << k) != 0 {
                    r = r * &self;
                }
                let self_ = self.clone();
                self = self * &self_;
            }
        }
        r
    }
}

const MODULOS: [u64; 21] = [27,
                            5,
                            49,
                            13,
                            19,
                            29,
                            37,
                            43,
                            73,
                            109,
                            113,
                            127,
                            337,
                            1429,
                            5419,
                            14449,
                            92737,
                            649657,
                            40388473189,
                            77158673929,
                            118750098349];

// These could be calculated as:
// import gmpy
// for m in MODULOS:
//     tmp = (2 ** 252 - 1) / m
//     print tmp * gmpy.invert(tmp, m) % (2 ** 252)
const EXPONENTIALS: [[u8; 32]; 21] =
    [[0xbd, 0x84, 0xf6, 0x12, 0xda, 0x4b, 0x68, 0x2f, 0xa1, 0xbd, 0x84, 0xf6, 0x12, 0xda, 0x4b,
      0x68, 0x2f, 0xa1, 0xbd, 0x84, 0xf6, 0x12, 0xda, 0x4b, 0x68, 0x2f, 0xa1, 0xbd, 0x84, 0xf6,
      0x12, 0x0a],
     [0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
      0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
      0xcc, 0x0c],
     [0xb1, 0x3e, 0x34, 0xd6, 0x87, 0xc6, 0xfa, 0xd0, 0x58, 0x1f, 0x1a, 0xeb, 0x43, 0x63, 0x7d,
      0x68, 0xac, 0x0f, 0x8d, 0xf5, 0xa1, 0xb1, 0x3e, 0x34, 0xd6, 0x87, 0xc6, 0xfa, 0xd0, 0x58,
      0x1f, 0x0a],
     [0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76,
      0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76, 0x62, 0x27, 0x76,
      0x62, 0x07],
     [0x79, 0x0d, 0xe5, 0x35, 0x94, 0xd7, 0x50, 0x5e, 0x43, 0x79, 0x0d, 0xe5, 0x35, 0x94, 0xd7,
      0x50, 0x5e, 0x43, 0x79, 0x0d, 0xe5, 0x35, 0x94, 0xd7, 0x50, 0x5e, 0x43, 0x79, 0x0d, 0xe5,
      0x35, 0x04],
     [0x4f, 0x23, 0x2c, 0xf7, 0x34, 0xc2, 0x72, 0x4f, 0x23, 0x2c, 0xf7, 0x34, 0xc2, 0x72, 0x4f,
      0x23, 0x2c, 0xf7, 0x34, 0xc2, 0x72, 0x4f, 0x23, 0x2c, 0xf7, 0x34, 0xc2, 0x72, 0x4f, 0x23,
      0x2c, 0x07],
     [0x30, 0x45, 0x3e, 0xeb, 0x06, 0x53, 0xe4, 0xb3, 0x6e, 0x30, 0x45, 0x3e, 0xeb, 0x06, 0x53,
      0xe4, 0xb3, 0x6e, 0x30, 0x45, 0x3e, 0xeb, 0x06, 0x53, 0xe4, 0xb3, 0x6e, 0x30, 0x45, 0x3e,
      0xeb, 0x06],
     [0x05, 0x7d, 0x41, 0x5f, 0xd0, 0x17, 0xf4, 0x05, 0x7d, 0x41, 0x5f, 0xd0, 0x17, 0xf4, 0x05,
      0x7d, 0x41, 0x5f, 0xd0, 0x17, 0xf4, 0x05, 0x7d, 0x41, 0x5f, 0xd0, 0x17, 0xf4, 0x05, 0x7d,
      0x41, 0x0f],
     [0x85, 0x0a, 0x15, 0x2a, 0x54, 0xa8, 0x50, 0xa1, 0x42, 0x85, 0x0a, 0x15, 0x2a, 0x54, 0xa8,
      0x50, 0xa1, 0x42, 0x85, 0x0a, 0x15, 0x2a, 0x54, 0xa8, 0x50, 0xa1, 0x42, 0x85, 0x0a, 0x15,
      0x2a, 0x04],
     [0x0e, 0xa2, 0xc7, 0x77, 0xe1, 0x20, 0x7a, 0x7c, 0x17, 0x0e, 0xa2, 0xc7, 0x77, 0xe1, 0x20,
      0x7a, 0x7c, 0x17, 0x0e, 0xa2, 0xc7, 0x77, 0xe1, 0x20, 0x7a, 0x7c, 0x17, 0x0e, 0xa2, 0xc7,
      0x77, 0x01],
     [0xc7, 0x28, 0xce, 0x75, 0x8c, 0xe2, 0x5c, 0xc7, 0x28, 0xce, 0x75, 0x8c, 0xe2, 0x5c, 0xc7,
      0x28, 0xce, 0x75, 0x8c, 0xe2, 0x5c, 0xc7, 0x28, 0xce, 0x75, 0x8c, 0xe2, 0x5c, 0xc7, 0x28,
      0xce, 0x05],
     [0x3c, 0x1e, 0x8f, 0xc7, 0xe3, 0xf1, 0x78, 0x3c, 0x1e, 0x8f, 0xc7, 0xe3, 0xf1, 0x78, 0x3c,
      0x1e, 0x8f, 0xc7, 0xe3, 0xf1, 0x78, 0x3c, 0x1e, 0x8f, 0xc7, 0xe3, 0xf1, 0x78, 0x3c, 0x1e,
      0x8f, 0x07],
     [0x67, 0xf8, 0xe9, 0x0c, 0x3f, 0x9d, 0xe1, 0xa7, 0x33, 0xfc, 0x74, 0x86, 0x9f, 0xce, 0xf0,
      0xd3, 0x19, 0x7e, 0x3a, 0xc3, 0x4f, 0x67, 0xf8, 0xe9, 0x0c, 0x3f, 0x9d, 0xe1, 0xa7, 0x33,
      0xfc, 0x04],
     [0xd6, 0x04, 0x11, 0xdd, 0xf6, 0xa6, 0xec, 0xbb, 0x8b, 0x24, 0x64, 0x4d, 0x10, 0xd1, 0x6d,
      0x6f, 0xca, 0xbe, 0xbb, 0x48, 0x42, 0xd6, 0x04, 0x11, 0xdd, 0xf6, 0xa6, 0xec, 0xbb, 0x8b,
      0x24, 0x04],
     [0x91, 0x53, 0xc5, 0x8d, 0x55, 0x47, 0x4e, 0x15, 0x37, 0x56, 0x1d, 0x39, 0x55, 0xdc, 0x58,
      0x75, 0xe4, 0x54, 0x71, 0x63, 0xd5, 0x91, 0x53, 0xc5, 0x8d, 0x55, 0x47, 0x4e, 0x15, 0x37,
      0x56, 0x0d],
     [0x8e, 0x65, 0x5c, 0x31, 0xfe, 0xc5, 0x69, 0x8e, 0x3a, 0x07, 0xe8, 0x58, 0xc6, 0x15, 0xe3,
      0x5f, 0x9c, 0xe6, 0xa8, 0x73, 0x80, 0x8e, 0x65, 0x5c, 0x31, 0xfe, 0xc5, 0x69, 0x8e, 0x3a,
      0x07, 0x08],
     [0x5e, 0x67, 0x3a, 0x9b, 0x58, 0x1e, 0x4f, 0x4b, 0xaf, 0x33, 0x9d, 0x4d, 0x2c, 0x8f, 0xa7,
      0xa5, 0xd7, 0x99, 0xce, 0x26, 0x96, 0xc7, 0xd3, 0xd2, 0xeb, 0x4c, 0x67, 0x13, 0xcb, 0xe3,
      0x69, 0x09],
     [0xc6, 0x38, 0x03, 0x90, 0xa8, 0xe3, 0x0a, 0x7e, 0x63, 0x9c, 0x01, 0x48, 0xd4, 0x71, 0x05,
      0xbf, 0x31, 0xce, 0x00, 0x24, 0xea, 0xb8, 0x82, 0xdf, 0x18, 0x67, 0x00, 0x12, 0x75, 0x5c,
      0xc1, 0x0f],
     [0x47, 0x08, 0xe3, 0x72, 0x1e, 0x8a, 0xdc, 0xd8, 0xbd, 0xf1, 0xb1, 0xed, 0x32, 0xc9, 0xdf,
      0x25, 0xee, 0x3d, 0x47, 0x63, 0x78, 0xdd, 0xc8, 0x89, 0x90, 0x83, 0x93, 0x44, 0xb3, 0x0d,
      0x88, 0x06],
     [0x31, 0x9d, 0x1d, 0xca, 0x6b, 0x7d, 0x04, 0x37, 0x67, 0x31, 0xf1, 0x1a, 0x4a, 0xc1, 0x7d,
      0x64, 0x4c, 0x67, 0x87, 0xf2, 0x5a, 0x1f, 0xc1, 0xcd, 0x59, 0x4c, 0xbc, 0x86, 0x52, 0x70,
      0x1f, 0x09],
     [0xcf, 0x65, 0x6c, 0x7f, 0x4e, 0xad, 0x6f, 0xa1, 0x66, 0x7a, 0xb9, 0x61, 0xbf, 0xa3, 0x01,
      0x11, 0x8c, 0xe6, 0x24, 0x60, 0xac, 0x14, 0xa4, 0x57, 0x66, 0xa1, 0x91, 0x27, 0x10, 0x97,
      0xbf, 0x0b]];

pub fn solve_dlp(p: &[u8; 32]) -> [u8; 32] {
    let p = Ge(unsafe { mem::transmute(*p) });
    let mut r = Ge([1, 0, 0, 0]);
    let g = Ge([2, 0, 0, 0]);

    // <sanity-checking>
    for (e, &m) in EXPONENTIALS.iter().zip(MODULOS.iter()) {
        r = r * &(p.clone().exp(e));

        let e2: [u8; 32] = unsafe { mem::transmute([m, 0, 0, 0]) };
        assert!(g.clone().exp(e) != Ge([1, 0, 0, 0]));
        assert!(p.clone().exp(e).exp(&e2) == Ge([1, 0, 0, 0]));
        assert!(g.clone().exp(e).exp(&e2) == Ge([1, 0, 0, 0]));
    }
    assert!(p == r);
    // </sanity-checking>

    let mut crt_val = Mpz::from(0u32);
    let mut crt_mod = Mpz::from(1u32);

    for (e, &m) in EXPONENTIALS.iter().zip(MODULOS.iter()) {
        let g = Ge([2, 0, 0, 0]).exp(e);
        let mut goal = p.clone().exp(e);

        let sqrt = (m as f64).sqrt() as u64;
        let mut g_pow_sqrt = Ge([1, 0, 0, 0]);

        for _ in 0..sqrt {
            g_pow_sqrt = g_pow_sqrt * &g;
        }

        let mut lookup: HashMap<Ge, u64> = HashMap::new();

        let mut a = Ge([1, 0, 0, 0]);
        for n in 0..(m / sqrt) {
            lookup.insert(a.clone(), n * sqrt);
            a = a * &g_pow_sqrt;
        }

        for n in 0.. {
            if let Some(&k) = lookup.get(&goal) {
                let k = (k + (m - n)) % m;
                crt_val += crt_mod.invert(&Mpz::from(m)).unwrap() * &crt_mod * (k - &crt_val);
                crt_mod *= m;
                crt_val %= &crt_mod;
                break;
            }
            goal = goal * &g;
        }
    }
    const EXPECTED: &'static [u8] = &[0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                      0xff, 0xff];
    assert!(crt_mod == Mpz::from(EXPECTED));
    let mut res = [0; 32];
    for n in 0..32 {
        for k in 0..8 {
            if crt_val.tstbit(n * 8 + k) {
                res[n] |= 1 << k;
            }
        }
    }
    res
}
