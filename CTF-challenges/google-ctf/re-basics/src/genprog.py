#!/usr/bin/python
# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# This generates the core part for the crackme.

import string
import random
from collections import OrderedDict

PROG_TEMPLATE = string.Template("""
# Generated flag checker code for bits ${first_bit} - ${last_bit}
.label ${checker_id}
# Make a loop in the linked list, just for the lolz.
2001 poke {rawaddr 2000 0 W __default}, {rawaddr 2000 0 L __default} : poke {rawaddr 2000 1 W __default}, {rawaddr 2000 0 H __default}
2002 poke 1024 + chkoff + ${checker_offset}, 81:poke 55296 + chkoff + ${checker_offset}, 7
# Decrypt.
2004 es = {rawaddr 2010 0 W ${checker_id}} : ee = {rawaddr 2500 -1 W ${checker_id}} : ek = &${enc_key}
2005 for i = es to ee : k = ( peek(i) + ek ) and 255 : poke i, k : next i
2009 poke 1024 + chkoff + ${checker_offset}, 87
.encrypted_start 0x${enc_key}
2010 v = ${initial_value} : g = 0
${lines_read_byte}
2025 p0 = 0:p1 = 0:p2 = 0:p3 = 0:p4 = 0:p5 = 0:p6 = 0:p7 = 0:p8 = 0:p9 = 0:pa = 0:pb = 0:pc = 0
2030 if b${bit0_byte_id} and ${bit0_power} then p0 = 0.062500000001818989403545856475830078125
2031 if b${bit1_byte_id} and ${bit1_power} then p1 = 0.0156250000004547473508864641189575195312
2032 if b${bit2_byte_id} and ${bit2_power} then p2 = 0.0039062500001136868377216160297393798828
2033 if b${bit3_byte_id} and ${bit3_power} then p3 = 0.0009765625000284217094304040074348449707
2034 if b${bit4_byte_id} and ${bit4_power} then p4 = 0.0002441406250071054273576010018587112427
2035 if b${bit5_byte_id} and ${bit5_power} then p5 = 0.0000610351562517763568394002504646778107
2036 if b${bit6_byte_id} and ${bit6_power} then p6 = 0.0000152587890629440892098500626161694527
2037 if b${bit7_byte_id} and ${bit7_power} then p7 = 0.0000038146972657360223024625156540423632
2040 if b${bit8_byte_id} and ${bit8_power} then p8 = 0.0000009536743164340055756156289135105908
2031 if b${bit9_byte_id} and ${bit9_power} then p9 = 0.0000002384185791085013939039072283776477
2032 if b${bit10_byte_id} and ${bit10_power} then pa = 0.0000000596046447771253484759768070944119
2033 if b${bit11_byte_id} and ${bit11_power} then pb = 0.000000014901161194281337118994201773603
2034 if b${bit12_byte_id} and ${bit12_power} then pc = 0.0000000037252902985703342797485504434007
2050 k = v + p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + pa + pb + pc
2060 g = ${correct_value}
2100 t${checker_letter_id} = k = g : a = 86 : b = 10
2200 if t${checker_letter_id} = -1 then a = 83 : b = 5
2210 poke 1024 + chkoff + ${checker_offset}, 90
.encrypted_end
2500 ${debug_line}
# Recrypt.
2900 for i = es to ee : k = ( peek(i) + ek ) and 255 : poke i, k : next i
2905 poke 1024 + chkoff + ${checker_offset}, a:poke 55296 + chkoff + ${checker_offset}, b
2910 poke {rawaddr 2000 0 W __default}, {rawaddr 2001 0 L ${next_checker_id}} : poke {rawaddr 2000 1 W __default}, {rawaddr 2001 0 H ${next_checker_id}} : goto 2001
.slash_list
2920 rem""")

READ_BYTE_TEMPLATE = string.Template("${line_number} b${byte_id} = asc( mid$$(p$$, ${byte_number_plus_one}, 1) )")

flag = "CTF[LINKED-LISTS-AND-40-BIT-FLOATS]"
tested_flag = flag[4:-1]
# linked-lists-and-40-bit-floats


def get_bit(s, bit):
  s = bytearray(s)
  i_byte = bit / 8
  i_bit = bit % 8
  return (i_byte, i_bit, (s[i_byte] >> i_bit) & 1)



# Generated by genvalues.py
CORRECT_VALUES = [
  "0.671565706376017",
  "0.682612358126820",
  "0.682552023325146",
  "0.667647300753773",
  "0.682310803327740",
  "0.670638734940470",
  "0.729427094105661",
  "0.683334092143953",
  "0.729182238224924",
  "0.682352954987467",
  "0.745769257191599",
  "0.666743217501820",
  "0.682352764997662",
  "0.670634204987467",
  "0.733381925616444",
  "0.667648012284220",
  "0.749690691474855",
  "0.682356773410023",
  "0.670817057136476",
]

# Initial values are created and tweaked by hand.
# 9, 12
INITIAL_VALUES = [
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 0
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 1
  "0.6666666666612316235641",  # 2
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 3
  "0.6666666666612316235641",  # 4
  "0.6666666666612316235641 - 0.00000000046566128730773925781250",  # 5
  "0.6666666666612316235641 - 0.00000000046566128730773925781250",  # 6
  "0.6666666666612316235641",  # 7
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 8
  "0.6666666666612316235641 + 0.00000000046566128730773925781250",  # 9
  "0.6666666666612316235641 - 0.00000000046566128730773925781250",  # 10
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 11
  "0.6666666666612316235641 + 0.00000000023283064365386962890625",  # 12
  "0.6666666666612316235641",  # 13
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 14
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 15
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 16
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 17
  "0.6666666666612316235641 - 0.00000000023283064365386962890625",  # 18
]


vs = 0
limit = len(tested_flag) * 8

ln = 0

byte_list = OrderedDict()
bit_info_list = []

for i in xrange(limit):
  i_byte, i_bit, i_value = get_bit(tested_flag, i)
  bit_info_list.append((i, i_byte, i_bit, i_value))

  byte_list[i_byte] = 1

  vs += 1

  if vs == 13 or i == limit - 1:
    byte_ids = { x : chr(0x61 + i) for i, x in enumerate(byte_list.keys()) }

    # Generate fetching bytes.
    fetching_bytes = []
    for i, (k, v) in enumerate(byte_ids.items()):
      fetching_bytes.append(
        READ_BYTE_TEMPLATE.safe_substitute({
            "line_number": "%i" % (2020 + i),
            "byte_id": v,
            "byte_number_plus_one": k + 1
        })
      )

    fetching_bytes = '\n'.join(fetching_bytes)

    info = {
        "checker_id": "check%i" % (ln),
        "checker_letter_id": "0123456789abcdefghj"[ln],
        "checker_offset": "%i" % (ln + 1),
        "next_checker_id": "check%i" % (ln + 1),
        "first_bit": "%i" % (bit_info_list[0][0]),
        "last_bit": "%i" % (bit_info_list[-1][0]),
        "correct_value": CORRECT_VALUES[ln],
        "initial_value": INITIAL_VALUES[ln],
        "enc_key": "%.2x" % random.randint(128, 255),
        "lines_read_byte": fetching_bytes,
        "debug_line": "rem"
    }

    # 2, 4, 5, 6, 7, 9, 10, 12, 13
    if ln in []:  # 6, 7, 9, 10, 12
      info["debug_line"] = "stop"

    for i, (_, i_byte, i_bit, _) in enumerate(bit_info_list):
      info["bit%i_byte_id" % i] = byte_ids[i_byte]
      info["bit%i_power" % i] = "%i" % (2 ** i_bit)

    while i < 13:
      i += 1
      info["bit%i_byte_id" % i] = 'x'
      info["bit%i_power" % i] = "%i" % (2 ** (i & 7))

    # Special magical patch.
    if info["next_checker_id"] == "check19":
      info["next_checker_id"] = "checkend"

    print PROG_TEMPLATE.safe_substitute(info)

    # Reset.
    byte_list = OrderedDict()
    vs = 0
    bit_info_list = []
    ln += 1
